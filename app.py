import streamlit as st
import re
import json
import requests
from datetime import datetime
import xml.etree.ElementTree as ET

# Configuration de la page
st.set_page_config(
    page_title="XML Auto-Corrector",
    page_icon="üîß",
    layout="wide"
)

def detect_and_decode(file_bytes):
    """Detecte l'encodage et decode le fichier"""
    encodings = ['utf-8', 'utf-8-sig', 'iso-8859-1', 'cp1252', 'latin1']
    
    for encoding in encodings:
        try:
            content = file_bytes.decode(encoding)
            return content, encoding
        except UnicodeDecodeError:
            continue
    
    content = file_bytes.decode('utf-8', errors='replace')
    return content, 'utf-8-with-errors'

@st.cache_data(ttl=300)  # Cache pendant 5 minutes
def load_corrections():
    """Charge les corrections depuis GitHub avec cache"""
    try:
        # URL corrig√©e du fichier corrections.json
        url = "https://raw.githubusercontent.com/younessemlali/xpo-xml-auto-corrector/main/corrections.json"
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            corrections = json.loads(response.text)
            # Normaliser les cl√©s pour s'assurer qu'elles ont des z√©ros de t√™te
            normalized_corrections = {}
            for order_id, data in corrections.items():
                # Normaliser la cl√© (ajouter des z√©ros si n√©cessaire)
                if order_id and order_id.isdigit() and len(order_id) < 6:
                    normalized_key = order_id.zfill(6)
                else:
                    normalized_key = order_id
                normalized_corrections[normalized_key] = data
            return normalized_corrections
        else:
            st.error(f"‚ùå Erreur GitHub: {response.status_code}")
            return {}
    except Exception as e:
        st.error(f"‚ùå Erreur de connexion: {str(e)}")
        return {}

def extract_all_order_numbers(xml_content):
    """Extrait TOUS les num√©ros de commande du XML (support multi-contrats)"""
    order_numbers = []
    
    try:
        # M√©thode 1: Regex pour chercher toutes les balises OrderId avec IdValue
        pattern = r'<OrderId[^>]*>\s*<IdValue>([^<]+)</IdValue>'
        matches = re.findall(pattern, xml_content, re.IGNORECASE)
        
        for match in matches:
            order_id = match.strip()
            # Normaliser avec des z√©ros de t√™te si n√©cessaire
            if order_id.isdigit() and len(order_id) < 6:
                order_id = order_id.zfill(6)
            if order_id not in order_numbers:
                order_numbers.append(order_id)
        
        # M√©thode 2: XML parsing comme fallback
        if not order_numbers:
            try:
                root = ET.fromstring(xml_content)
                for order_id_elem in root.iter():
                    if 'OrderId' in str(order_id_elem.tag):
                        id_value = order_id_elem.find('.//IdValue')
                        if id_value is not None and id_value.text:
                            order_id = id_value.text.strip()
                            # Normaliser avec des z√©ros de t√™te si n√©cessaire
                            if order_id.isdigit() and len(order_id) < 6:
                                order_id = order_id.zfill(6)
                            if order_id not in order_numbers:
                                order_numbers.append(order_id)
            except ET.ParseError:
                pass
        
        return order_numbers
    except Exception:
        return []

def add_customer_job_code(xml_content, job_code):
    """Ajoute la balise CustomerJobCode apr√®s CostCenterName"""
    try:
        # V√©rifier si CustomerJobCode existe d√©j√†
        if '<CustomerJobCode>' in xml_content:
            # Remplacer la valeur existante
            xml_content = re.sub(
                r'<CustomerJobCode>[^<]*</CustomerJobCode>',
                f'<CustomerJobCode>{job_code}</CustomerJobCode>',
                xml_content
            )
            return xml_content, "mise_a_jour"
        else:
            # Pattern pour trouver CostCenterName et ajouter CustomerJobCode juste apr√®s
            pattern = r'(<CostCenterName>[^<]*</CostCenterName>)'
            replacement = f'\\1\n        <CustomerJobCode>{job_code}</CustomerJobCode>'
            
            # Compter les occurrences pour s'assurer qu'on fait la substitution
            matches = re.findall(pattern, xml_content)
            if matches:
                xml_content = re.sub(pattern, replacement, xml_content)
                return xml_content, "ajout"
            else:
                # Si CostCenterName n'est pas trouv√©, essayer d'autres emplacements
                # Chercher apr√®s <OrderId>...</OrderId>
                order_pattern = r'(<OrderId[^>]*>.*?</OrderId>)'
                if re.search(order_pattern, xml_content, re.DOTALL):
                    order_replacement = f'\\1\n        <CustomerJobCode>{job_code}</CustomerJobCode>'
                    xml_content = re.sub(order_pattern, order_replacement, xml_content, flags=re.DOTALL)
                    return xml_content, "ajout_alternatif"
                else:
                    return xml_content, "emplacement_non_trouve"
    
    except Exception as e:
        return xml_content, f"erreur: {str(e)}"

def apply_corrections_to_xml(xml_content, order_numbers, corrections):
    """Applique les corrections pour toutes les commandes d√©tect√©es"""
    all_applied_corrections = []
    corrected_xml = xml_content
    
    for order_number in order_numbers:
        if order_number in corrections:
            order_corrections = corrections[order_number]
            
            for field, value in order_corrections.items():
                if field == "CustomerJobCode":
                    corrected_xml, status = add_customer_job_code(corrected_xml, value)
                    if status in ["ajout", "mise_a_jour", "ajout_alternatif"]:
                        all_applied_corrections.append(
                            f"Commande {order_number} - CustomerJobCode: {value} ({status.replace('_', ' ')})"
                        )
                    else:
                        all_applied_corrections.append(
                            f"Commande {order_number} - CustomerJobCode: √âCHEC ({status})"
                        )
                # Ici on peut ajouter d'autres types de corrections
    
    return corrected_xml, all_applied_corrections

def main():
    """Interface principale"""
    
    # Titre et description
    st.title("üîß XML Auto-Corrector XPO")
    st.write("Correction automatique des fichiers XML selon les non-conformit√©s PIXID")
    
    # Charger les corrections disponibles
    with st.spinner("üîÑ Chargement des corrections depuis GitHub..."):
        corrections = load_corrections()
    
    if corrections:
        st.success(f"‚úÖ {len(corrections)} corrections disponibles")
        
        # Afficher un aper√ßu des corrections disponibles
        with st.expander("üìã Aper√ßu des corrections disponibles"):
            for order_num, order_corrections in list(corrections.items())[:5]:
                st.write(f"**Commande {order_num}:**")
                for field, value in order_corrections.items():
                    st.write(f"  ‚Ä¢ {field}: `{value}`")
            if len(corrections) > 5:
                st.write(f"... et {len(corrections) - 5} autres commandes")
    else:
        st.warning("‚ö†Ô∏è Aucune correction disponible pour le moment")
        st.info("üí° V√©rifiez la connexion √† GitHub ou attendez que de nouvelles corrections soient ajout√©es")
    
    st.write("---")
    
    # Upload du fichier XML
    st.header("üìÅ Upload du fichier XML")
    xml_file = st.file_uploader(
        "Choisissez votre fichier XML √† corriger",
        type=['xml'],
        help="Le fichier sera automatiquement corrig√© selon les donn√©es disponibles. Support multi-contrats."
    )
    
    if xml_file is not None:
        # Lire le fichier XML
        xml_content, xml_encoding = detect_and_decode(xml_file.read())
        st.success(f"‚úÖ XML lu avec l'encodage: {xml_encoding}")
        
        # Extraire TOUS les num√©ros de commande
        order_numbers = extract_all_order_numbers(xml_content)
        
        if order_numbers:
            st.info(f"üè∑Ô∏è Num√©ro(s) de commande d√©tect√©(s): **{', '.join(order_numbers)}**")
            
            # V√©rifier quelles commandes ont des corrections disponibles
            available_corrections = {}
            missing_corrections = []
            
            for order_number in order_numbers:
                if order_number in corrections:
                    available_corrections[order_number] = corrections[order_number]
                else:
                    missing_corrections.append(order_number)
            
            if available_corrections:
                st.success(f"‚úÖ Corrections trouv√©es pour {len(available_corrections)} commande(s)")
                
                # Afficher les corrections qui vont √™tre appliqu√©es
                st.write("**Corrections √† appliquer:**")
                for order_num, order_corrections in available_corrections.items():
                    st.write(f"üìã **Commande {order_num}:**")
                    for field, value in order_corrections.items():
                        st.write(f"  ‚Ä¢ **{field}**: `{value}`")
                
                # Bouton pour appliquer les corrections
                if st.button("üîÑ Appliquer les corrections", type="primary"):
                    with st.spinner("üîß Application des corrections..."):
                        corrected_xml, applied_corrections = apply_corrections_to_xml(
                            xml_content, order_numbers, corrections
                        )
                    
                    if applied_corrections:
                        st.success("‚úÖ Corrections appliqu√©es avec succ√®s!")
                        
                        # Afficher les corrections appliqu√©es
                        st.write("**Corrections appliqu√©es:**")
                        for correction in applied_corrections:
                            if "√âCHEC" in correction:
                                st.error(f"‚ùå {correction}")
                            else:
                                st.write(f"‚úÖ {correction}")
                        
                        # Bouton de t√©l√©chargement
                        timestamp = datetime.now().strftime('%H%M%S')
                        filename = f"{xml_file.name.split('.')[0]}_corrected_{timestamp}.xml"
                        
                        # Encoder en ISO-8859-1 pour le t√©l√©chargement
                        try:
                            xml_bytes = corrected_xml.encode('iso-8859-1', errors='replace')
                        except:
                            xml_bytes = corrected_xml.encode('utf-8', errors='replace')
                        
                        st.download_button(
                            label="üì• T√©l√©charger le XML corrig√©",
                            data=xml_bytes,
                            file_name=filename,
                            mime="application/xml"
                        )
                    else:
                        st.warning("‚ö†Ô∏è Aucune correction n'a pu √™tre appliqu√©e")
            
            if missing_corrections:
                st.warning(f"‚ö†Ô∏è Aucune correction trouv√©e pour: **{', '.join(missing_corrections)}**")
                st.info("üí° Ces commandes ne n√©cessitent peut-√™tre pas de correction ou seront ajout√©es ult√©rieurement")
        
        else:
            st.error("‚ùå Impossible d'extraire le num√©ro de commande du fichier XML")
            st.info("üí° V√©rifiez que le fichier contient bien une balise OrderId avec IdValue")
            
            # Afficher un aper√ßu du XML pour debug
            with st.expander("üîç Aper√ßu du contenu XML (pour debug)"):
                st.text(xml_content[:1000] + "..." if len(xml_content) > 1000 else xml_content)
    
    # Informations sur le syst√®me
    st.write("---")
    st.header("‚ÑπÔ∏è Comment √ßa marche")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**üîÑ Processus automatique:**")
        st.write("1. üìß R√©ception email non-conformit√©")
        st.write("2. ü§ñ Extraction automatique Google Sheets")
        st.write("3. üîÑ Synchronisation GitHub toutes les 15min")
        st.write("4. üîß Correction XML instantan√©e")
        st.write("5. üì• T√©l√©chargement fichier corrig√©")
    
    with col2:
        st.write("**üìã Fonctionnalit√©s:**")
        st.write("‚Ä¢ **Multi-contrats**: Support plusieurs commandes/XML")
        st.write("‚Ä¢ **Auto-sync**: Donn√©es mises √† jour automatiquement")
        st.write("‚Ä¢ **Z√©ros pr√©serv√©s**: Format 000721, 001043...")
        st.write("‚Ä¢ **Cache intelligent**: Performance optimis√©e")
        st.write("‚Ä¢ **Robuste**: Gestion d'erreurs avanc√©e")
    
    # Statut du syst√®me
    st.write("---")
    st.header("üìä Statut du syst√®me")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if corrections:
            st.metric("üóÇÔ∏è Corrections", len(corrections))
        else:
            st.metric("üóÇÔ∏è Corrections", "0", "‚ùå")
    
    with col2:
        # Afficher l'heure de derni√®re mise √† jour
        current_time = datetime.now().strftime('%H:%M:%S')
        st.metric("üïí Derni√®re v√©rification", current_time)
    
    with col3:
        # Bouton pour forcer le rechargement
        if st.button("üîÑ Recharger corrections"):
            st.cache_data.clear()
            st.rerun()
    
    # Derni√®re mise √† jour
    if corrections:
        st.write("---")
        st.caption(f"üîó Source: GitHub - younessemlali/xpo-xml-auto-corrector")
        st.caption(f"üïí Cache: 5 minutes | Sync auto: 15 minutes")

if __name__ == "__main__":
    main()
